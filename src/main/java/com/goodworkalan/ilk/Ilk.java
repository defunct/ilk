package com.goodworkalan.ilk;

import java.io.Serializable;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

/**
 * An implementation of type tokens or Gafter’s Gadget that generates a navigable
 * model of the parameterized types.
 *  
 * @author Alan Gutierrez
 *
 * @param <T>
 */
public class Ilk<T>
{
    public final Key key;

    /**
     * Generate a super type token from the type parameters given in the class
     * type declaration.
     * <p>
     * This method is meant to be called from anonymous subclasses of
     * <code>Ilk</code>.
     */
    protected Ilk()
    {
        // Give me class information.  
        Class<?> klass = getClass();  
       
        // See that I have created an anonymous subclass of TypeReference in the  
        // main method. Hence, to get the TypeReference itself, I need superclass.  
        // Furthermore, to get Type information, you should call  
        // getGenericSuperclass() instead of getSuperclass().  
        java.lang.reflect.Type superClass = klass.getGenericSuperclass();  
       
        if (superClass instanceof Class)
        {  
            // Type has four subinterface:  
            // (1) GenericArrayType: component type is either a  
            // parameterized type or a type variable. Parameterized type is a class  
            // or interface with its actual type argument, e.g., ArrayList<String>.  
            // Type variable is unqualified identifier like T or V.  
            //  
            // (2) ParameterizedType: see (1).  
            //  
            // (3) TypeVariable<D>: see (1).  
            //  
            // (4) WildcardType: ?  
            //  
            // and one subclass:  
            // (5) Class.  
            //  
            // If TypeReference is created by 'new TypeReference() { }', then  
            // superClass would be just an instance of Class instead of one of the  
            // interfaces described above. In that case, because I don't have type  
            // passed to TypeReference, an exception should be raised.  
            throw new RuntimeException("Missing Type Parameter");  
        }  
       
        // By superClass, we mean 'TypeReference<T>'. So, it is obvious that  
        // superClass is ParameterizedType.  
        ParameterizedType pt = (ParameterizedType) superClass;  
       
        // We have one type argument in TypeRefence<T>: T.  
        key = new Ilk.Key(pt.getActualTypeArguments()[0]);  
    }

    /**
     * A navigable tree model of parameter type declaration. This class is a
     * structure containing the class and type parameters of a super type token
     * generated by creating a subclass of <code>Ilk</code>.
     * 
     * @author Alan Gutierrez
     */
    public final static class Key implements Serializable
    {
        private static final long serialVersionUID = 1L;

        /** The class of the object. */
        final Class<?> keyClass;
        
        /** The cached hash code for this key. */
        final int hashCode;
        
        /** A key for each type parameter of the class. */
        final Key[] parameters;

        /**
         * Create a key for the given type.
         * <p>
         * The constructor will recursively create a key for each of the type
         * parameters of the type. It will calculate and cache the hash code,
         * since it is assumed that this class will primarily be used as a key
         * in map lookups.
         * 
         * @param type
         *            The type for which to generate a key.
         */
        public Key(Type type)
        {
            this.keyClass = getKeyClass(type);
            this.parameters = getParameterKeys(type);
            this.hashCode = getHashCode(keyClass.hashCode(), parameters);
        }

        /**
         * Generate a hash code by combining the hash code of the class of the
         * type token with the hash code of each of the type parameters of type
         * token.
         * 
         * @param hashCode
         *            The hash code of the class of the type token.
         * @param parameters
         *            The type parameters of the type token.
         * @return A combined hash code.
         */
        public int getHashCode(int hashCode, Key[] parameters)
        {
            for (Key key : parameters)
            {
                hashCode = hashCode * 37 + key.hashCode(); 
            }
            return hashCode;
        }

        /**
         * Return the class of the super type token type.
         * 
         * @param type
         *            The type.
         * @return The class of the super type token.
         */
        private static Class<?> getKeyClass(Type type)
        {
            if (type instanceof ParameterizedType)
            {
                return (Class<?>) ((ParameterizedType) type).getRawType();
            }
            else if (type instanceof Class)
            {
                return (Class<?>) type;
            }
            throw new IllegalArgumentException();
        }

        /**
         * Create an array of keys for the type parameters of the given type.
         * 
         * @param type
         *            The type.
         * @return An array of keys for the type parameters of the given type.
         */
        private Key[] getParameterKeys(Type type)
        {
            if (type instanceof ParameterizedType)
            {
                ParameterizedType pt = (ParameterizedType) type;
                Key[] parameters = new Key[pt.getActualTypeArguments().length];
                for (int i = 0; i < parameters.length; i++)
                {
                    parameters[i] = new Key(pt.getActualTypeArguments()[i]);
                }
                return parameters;
            }
            else if (type instanceof Class)
            {
                return new Key[0];
            }
            throw new IllegalArgumentException();
        }
        
        /**
         * Get the class of the super type token.
         * 
         * @return The class of the super type token.
         */
        public Class<?> getKeyClass()
        {
            return keyClass;
        }

        /**
         * Return the key for a type parameter of the super type token. Type
         * parameters are referenced by a zero based index and ordered according
         * to the their order in the class type parameter declaration.
         * 
         * @param index
         *            The index of the type parameter.
         * @return The key for the type parameter at the given index.
         */
        public Key get(int index)
        {
            return parameters[index];
        }

        /**
         * Determines if the class or interface represented by this key and all
         * parameterized types in the hierarchy of parameterized types is either
         * the same as, or is a superclass or superinterface of, the class or
         * interface of the class or interface in the same position in the
         * hierarchy represented by the given key. It returns <code>true</code>
         * if so; otherwise it returns <code>false</code>.
         * 
         * @param key
         *            The key to assign from.
         * @return True if the key can be assigned to an object represented by
         *         this key.
         */
        public boolean isAssignableFrom(Key key)
        {
            boolean assignable = keyClass.isAssignableFrom(key.keyClass)  && parameters.length == key.parameters.length;
            for (int i = 0; assignable && i < parameters.length; i++)
            {
                assignable = parameters[i].isAssignableFrom(key.parameters[i]);
            }
            return assignable;
        }

        /**
         * Two keys are equal if the key classes are equal and the keys for each
         * of the type parameters at each position are equal. That is, both keys
         * have the name number of type parameters and each of the keys of the
         * type parameter in this key is equal to the key of type parameter of
         * the given key at the parallel position.
         * 
         * @param object
         *            The object to test for equality.
         */
        @Override
        public boolean equals(Object object)
        {
            if (object instanceof Key)
            {
                Key key = (Key) object;
                boolean equals = keyClass.equals(key.keyClass) && parameters.length == key.parameters.length;
                for (int i = 0; equals && i < parameters.length; i++)
                {
                    equals = parameters[i].equals(key.parameters[i]);
                }
                return equals;
            }
            return false;
        }

        /**
         * Return a hash code that combines the hash code of the key class with
         * the hash codes of each of the keys for the type parameters of the key
         * class.
         * 
         * @return The hash code.
         */
        @Override
        public int hashCode()
        {
            return hashCode;
        }
    }
}
