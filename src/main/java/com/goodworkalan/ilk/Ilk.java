package com.goodworkalan.ilk;

import static com.goodworkalan.ilk.Types.getRawClass;

import java.io.Serializable;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Queue;

/**
 * An implementation of type tokens or Gafter's Gadget that generates a
 * navigable model of the parameterized types.
 * 
 * @author Alan Gutierrez
 * 
 * @param <T>
 *            The type to tokenize.
 */
public class Ilk<T> {
    /** The super type token key. */
    public final Key key;

    /**
     * Create a super type token for the given class.
     * 
     * @param keyClass
     *            The class.
     */
    public Ilk(Class<T> keyClass) {
        this.key = new Key(keyClass);
    }

    /**
     * Generate a super type token from the type parameters given in the class
     * type declaration.
     * <p>
     * This method is meant to be called from anonymous subclasses of
     * <code>Ilk</code>.
     */
    protected Ilk(Ilk.Key...keys) {
        // Give me class information.
        Class<?> klass = getClass();

        // See that I have created an anonymous subclass of TypeReference in the  
        // main method. Hence, to get the TypeReference itself, I need superclass.  
        // Furthermore, to get Type information, you should call  
        // getGenericSuperclass() instead of getSuperclass().  
        Type superClass = klass.getGenericSuperclass();  
       
        if (superClass instanceof Class<?>) {
            // Type has four subinterface:  
            // (1) GenericArrayType: component type is either a  
            // parameterized type or a type variable. Parameterized type is a class  
            // or interface with its actual type argument, e.g., ArrayList<String>.  
            // Type variable is unqualified identifier like T or V.  
            //  
            // (2) ParameterizedType: see (1).  
            //  
            // (3) TypeVariable<D>: see (1).  
            //  
            // (4) WildcardType: ?  
            //  
            // and one subclass:  
            // (5) Class.  
            //  
            // If TypeReference is created by 'new TypeReference() { }', then  
            // superClass would be just an instance of Class instead of one of the  
            // interfaces described above. In that case, because I don't have type  
            // passed to TypeReference, an exception should be raised.  
            throw new IllegalStateException("Missing Type Parameter");  
        }  
       
        // By superClass, we mean 'TypeReference<T>'. So, it is obvious that  
        // superClass is ParameterizedType.  
        ParameterizedType pt = (ParameterizedType) superClass;  
       
        // We have one type argument in TypeRefence<T>: T.  
        key = new Ilk.Key(pt.getActualTypeArguments()[0], keys);  
    }

    /**
     * Create a box that contains the given object that can return the given
     * object cast to the appropriate parameterized type using another ilk
     * instance.
     * 
     * @param object
     *            The object to box.
     * @return A box containing the object.
     */
    public Box box(T object) {
        return new Box(key, object);
    }

    /**
     * Get a list of constructors for the key class.
     * 
     * @return A list of constructors.
     */
    public List<Constructor<T>> getConstructors() {
        List<Constructor<T>> constructors = new ArrayList<Constructor<T>>();
        for (Constructor<?> constructor : getRawClass(key.type).getConstructors()) {
            constructors.add(UncheckedCast.<Constructor<T>>cast(constructor));
        }
        return constructors;
    }
    
    /**
     * A navigable tree model of parameter type declaration. This class is a
     * structure containing the class and type parameters of a super type token
     * generated by creating a subclass of <code>Ilk</code>.
     * 
     * @author Alan Gutierrez
     */
    public final static class Key implements Serializable, Comparable<Key> {
        /** The serial version id. */
        private static final long serialVersionUID = 1L;

        /** The cached hash code for this key. */
        private final int hashCode;
        
        /** The type. */
        public final Type type;
        
        /** The raw type as a class. */
        public final Class<?> rawClass;

        /**
         * Create a key around the given type.
         * 
         * @param type
         *            The type.
         */
        public Key(Type type, Key...keys) {
            this.type = actualize(type, keys);
            this.rawClass = getRawClass(type);
            this.hashCode = makeHashCode(type);
        }
        
        private static Type actualize(Type type, Key...keys) {
            if (keys.length == 0) {
                return type; 
            }
            return actualize(type, new LinkedList<Key>(Arrays.asList(keys)));
        }
        
        private static Type actualize(Type type, Queue<Key> keys) {
            if (type instanceof ParameterizedType) {
                ParameterizedType pt = (ParameterizedType) type;
                Type[] arguments = pt.getActualTypeArguments();
                Type[] actualized = new Type[arguments.length];
                boolean dirty = false;
                for (int i = 0, stop = arguments.length; i < stop; i++) {
                    actualized[i] = actualize(arguments[i], keys);
                    dirty = dirty || actualized[i] != arguments[i];
                }
                if (dirty) {
                    return new Types.ParameterizedType(pt, actualized);
                }
            } else if (type instanceof TypeVariable<?>) {
                Key parameter = keys.poll();
                if (parameter == null) {
                    throw new NoSuchElementException();
                }
                TypeVariable<?> variable = (TypeVariable<?>) type;
                for (Type bound : variable.getBounds()) {
                    if (!isAssignableFrom(bound, parameter.type)) {
                        throw new IllegalArgumentException();
                    }
                }
                return parameter.type;
            }
            return type;
        }

        /**
         * Using the given source type to lookup actual type parameters, resolve
         * the actual value of the given type variable.
         * 
         * @param source
         *            The source type to lookup actual type parameters.
         * @param typeVariable
         *            The type variable to actualize.
         * @return The actual parameterized type or class of the type variable.
         */
        private Type actualize(Type derived, TypeVariable<?> typeVariable) {
            Type actualized = typeVariable;
            while (actualized instanceof TypeVariable<?>) {
                Class<?> declaredBy = (Class<?>) ((TypeVariable<?>) actualized).getGenericDeclaration();
                Type createdWith = find(derived, declaredBy);
                Type[] parameters = declaredBy.getTypeParameters();
                for (int i = 0; ; i++)  {
                    if (parameters[i].equals(actualized)) {
                        actualized = ((ParameterizedType) createdWith).getActualTypeArguments()[i];
                        break;
                    }
                }
            }
            return actualized;
        }

        /**
         * Get a key that encapsulates the actual type parameters of the given
         * super class or super interface of the raw class of this key.
         * 
         * @param keyClass
         *            The super class or super interface.
         * @return A key that encapsulates the actual type parameters of the
         *         given super class or null if the given key class is not a
         *         super class or super interface of the raw class of this key.
         */
        public Key getSuperKey(Class<?> keyClass) {
            Type found = find(type, keyClass);
            if (found != null) {
                return getActualType(found);
            }
            return null;
        }
        
        public Key getActualType(Type found) {
            if (found instanceof ParameterizedType) {
                ParameterizedType pt = (ParameterizedType) found;
                Type[] parameters = new Type[getRawClass(found).getTypeParameters().length];
                for (int i = 0, stop = parameters.length; i < stop; i++) {
                    parameters[i] = actualize(type, getRawClass(found).getTypeParameters()[i]);
                }
                return new Key(new Types.ParameterizedType(pt, parameters));
            }
            return new Key(found);

        }

        public Key[] getActualTypes(Type[] params) {
            Key[] keys = new Key[params.length];
            for (int i = 0, stop = params.length; i < stop; i++) {
                keys[i] = getActualType(params[i]);
            }
            return keys;
        }
        
        public Ilk.Box newInstance(Constructor<?> constructor, Ilk.Box[] arguments)
        throws InstantiationException, IllegalAccessException, InvocationTargetException { 
            return new Box(this, constructor.newInstance(objects(constructor.getGenericParameterTypes(), arguments)));
        }
        
        public Ilk.Box invoke(Method method, Ilk.Box object, Ilk.Box[] arguments)
        throws IllegalAccessException, InvocationTargetException {
            isAssignableFrom(object.key);
            return enbox(getActualType(method.getGenericReturnType()), method.invoke(object.object, objects(method.getGenericParameterTypes(), arguments)));
//            Object result = method.invoke(object.object, objects(method.getGenericParameterTypes(), arguments));
//            if (result == null) {
//                return null;
//            }
//            return new Ilk.Box(getActualType(method.getGenericReturnType()), result);
        }
        
        public void set(Field field, Ilk.Box object, Ilk.Box value)
        throws IllegalAccessException {
            isAssignableFrom(object.key);
            getActualType(field.getGenericType()).isAssignableFrom(value.key);
            field.set(object.object, value.object);
        }
        
        Ilk.Box enbox(Key key, Object object) {
            if (object == null) {
                return null;
            }
            return new Box(key, object);
        }

        public Ilk.Box get(Field field, Ilk.Box object)
        throws IllegalAccessException {
            isAssignableFrom(object.key);
//            Object result =  field.get(object.object);
//            if (result == null) {
//                return null;
//            }
//            return new Ilk.Box(getActualType(field.getGenericType()), field.get(object.object));
            return enbox(getActualType(field.getGenericType()), field.get(object.object));
        }

        public Object[] objects(Type[] types, Box[] boxes) {
            Key[] keys = getActualTypes(types);
            for (int i = 0; i < types.length; i++) {
                if (boxes[i] != null && !keys[i].isAssignableFrom(boxes[i].key)) {
                    throw new IllegalArgumentException();
                }
            }
            Object[] objects = new Object[boxes.length];
            for (int i = 0; i < objects.length; i++) {
                objects[i] = boxes[i] == null ? null : boxes[i].object;
            }
            return objects;
        }

        /**
         * Order keys by first by their assignability, where most derived types
         * are less than least derived types, then by their to string values.
         * Most derived types are less than their super types so that ordering
         * keys creates a series where the most derived type is earlier in the
         * series than its super types. The series can be used to find a best
         * match for a type where the most derived is considered the most
         * specific.
         * 
         * @return negative integer if this key is assignable to the given key,
         *         a positive integer if this key is assignable from the given
         *         key, or zero if they are both assignable to each other, or if
         *         no assignments are possible, the result of comparing the to
         *         string values.
         */
        public int compareTo(Key o) {
            if (isAssignableFrom(o)) {
                if (o.isAssignableFrom(this)) {
                    return 0;
                }
                return 1;
            } else if (o.isAssignableFrom(this)) {
                return -1;
            }
            return toString().compareTo(o.toString());
        }

        /**
         * Create a copy of this super type token.
         * 
         * @param key
         *            The key to copy.
         */
        public Key(Key key) {
            this.type = key.type;
            this.rawClass = key.rawClass;
            this.hashCode = key.hashCode;
        }

        /**
         * Using the given type declaration, find the definition of the given
         * target class in the class hierarchy of the raw class associated with
         * the type definition. Returns null if the target class is not part of
         * the class hierarchy of the type definition.
         * 
         * @param source
         *            The type definition.
         * @param target
         *            The target class.
         * @return The type definition of the class in the class hierarchy or
         *         null if it is not found.
         */
        private Type find(Type source, Class<?> target) {
            if (getRawClass(source).equals(target)) {
                return source;
            }
            if (target.isInterface()) {
                LinkedList<Type> interfaces = null;
                interfaces = new LinkedList<Type>();
                while (source != null) {
                    interfaces.addFirst(source);
                    while (!interfaces.isEmpty()) {
                        Class<?> candidate = getRawClass(interfaces.removeFirst());
                        for (Type type : candidate.getGenericInterfaces()) {
                            if (type instanceof ParameterizedType) {
                                ParameterizedType pt = (ParameterizedType) type;
                                if (pt.getRawType().equals(target)) {
                                    return pt;
                                }
                            } else if (type.equals(target)) {
                                return type;
                            }
                        }
                        interfaces.addAll(Arrays.<Type>asList(candidate.getGenericInterfaces()));
                    }
                    source = getRawClass(source).getGenericSuperclass();
                }
            } else {
                for (;;) {
                    Type candidate = getRawClass(source).getGenericSuperclass();
                    if (candidate == null) {
                        break;
                    }
                    if (candidate instanceof ParameterizedType) {
                        ParameterizedType pt = (ParameterizedType) candidate;
                        if (pt.getRawType().equals(target)) {
                            return pt;
                        }
                    } else if (target.equals(candidate)) {
                        return candidate;
                    }
                    source = candidate;
                }
            }
            return null;
        }

        /**
         * For each element in the to array, if it is a wildcard, evaluate the
         * wildcard against the element at the same index in the from array,
         * otherwise test the element for equality against the same the element
         * at the same index in the from array.
         * 
         * @param to
         *            The types to assign to.
         * @param from
         *            The types to assign from.
         * @return True if the types in from can be assinged to the types in to.
         */
        private static boolean evaluateWildcards(Type[] to, Type[] from) {
            for (int i = 0, stop = to.length; i < stop; i++) {
                if (!evaluateWildcards(to[i], from[i])) {
                    return false;
                }
            }
            return true;
        }

        /**
         * If the given to type is a wildcard, test the wildcard against the
         * given from type if it is not also a wildcard, otherwise test the two
         * types for equalty.
         * 
         * @param to
         *            The type to assign to.
         * @param from
         *            The type to assign from.
         * @return True if the types in from can be assinged to the types in to.
         */
        public static boolean evaluateWildcards(Type to, Type from ) {
            if (to instanceof WildcardType && !(from instanceof WildcardType)) {
                WildcardType toWildcard = (WildcardType) to;
                for (Type type : toWildcard.getLowerBounds()) {
                    if (!isAssignableFrom(from, type)) {
                        return false;
                    }
                }
                for (Type type : toWildcard.getUpperBounds()) {
                    if (!isAssignableFrom(type, from)) {
                        return false;
                    }
                }
                return true;
            }
            return equals(to, from);
        }

        /**
         * Determine of the type given in from can be assigned to type type
         * given in to.
         * 
         * @param to
         *            The type to assign to.
         * @param from
         *            The type to assign from.
         * @return True if the type from can be assigned to the type to.
         */
        private static boolean isAssignableFrom(Type to, Type from) {
            if (getRawClass(to).isAssignableFrom(getRawClass(from))) {
                if (to instanceof ParameterizedType) {
                    return equals(((ParameterizedType) to).getActualTypeArguments(), ((ParameterizedType) from).getActualTypeArguments());
                }
                return true;
            }
            return false;
        }

        /**
         * Determines if the class or interface represented by this key and all
         * parameterized types in the hierarchy of parameterized types is either
         * the same as, or is a superclass or super-interface of, the class or
         * interface of the class or interface in the same position in the
         * hierarchy represented by the given key. It returns <code>true</code>
         * if so; otherwise it returns <code>false</code>.
         * 
         * @param key
         *            The key to assign from.
         * @return True if the key can be assigned to an object represented by
         *         this key.
         */
        public boolean isAssignableFrom(Key key) {
            if (getRawClass(type).isAssignableFrom(getRawClass(key.type))) {
                if (type instanceof Class<?>) { 
                    return true;
                }
                Ilk.Key adjusted = key.getSuperKey(getRawClass(type));
                return evaluateWildcards(((ParameterizedType) type).getActualTypeArguments(), ((ParameterizedType) adjusted.type).getActualTypeArguments());
            }
            return false;
        }

        /**
         * Two keys are equal if the underlying types are equal. The underlying
         * types are equal if they are both classes and they are equal, or if
         * they are one of the other types and all of their properties are
         * equal.
         * 
         * @param object
         *            The object to test for equality.
         * @return True if this object is eqaual to the given object.
         */
        @Override
        public boolean equals(Object object) {
            if (object == this) {
                return true;
            }
            if (object instanceof Key) {
                return equals(type, ((Key) object).type);
            }
            return false;
        }
        
        /**
         * Determine if the two arrays are the same length and if each element
         * in the left array is equal to the element at the same index in the
         * right array.
         * 
         * @param left
         *            One of two arrays to compare for equality.
         * @param right
         *            One of two arrays to compare for equality.
         * @return True if the arrays are equal.
         */
        private static boolean equals(Type[] left, Type[] right) {
            for (int i = 0, stop = left.length; i < stop; i++) {
                if (!equals(left[i], right[i])) {
                    return false;
                }
            }
            return true;
        }

        /**
         * Test two parameterized types to determine if they are equal. Two
         * parameterized types are equal if their owner types are equal or are
         * both null, their raw types are equal, their actual parameters arrays
         * are the same length and each element in the actual parameters array
         * is equal to the element in at the same index of the other actual
         * parameter array.
         * 
         * @param left
         *            One of two parameterized types to test for equality.
         * @param right
         *            One of two parameterized types to test for equality.
         * @return True if the parameterized types are equal.
         */
        private static boolean equals(ParameterizedType left, ParameterizedType right) {
            return equals(left.getRawType(), right.getRawType())
                && equals(left.getOwnerType(), right.getOwnerType())
                && equals(left.getActualTypeArguments(), right.getActualTypeArguments());
        }

        /**
         * Test two wildcard types to determine if they are equal. Two
         * parameterized types are equal the types of their upper and lower
         * bounds are equal. For now, we are only encountering arrays of bounds
         * with one element, but if we do encounter arrays of bounds with more
         * than one element, we'll need to implement set equality.
         * 
         * @param left
         *            One of two parameterized types to test for equality.
         * @param right
         *            One of two parameterized types to test for equality.
         * @return True if the parameterized types are equal.
         */
        private static boolean equals(WildcardType left, WildcardType right) {
            return equals(left.getLowerBounds(), right.getLowerBounds())
                && equals(left.getUpperBounds(), right.getUpperBounds());
        }

        /**
         * Determine if the two types are equal. Two types are equal if they are
         * the same class and all of their properties are equal.
         * <p>
         * Equality does not appear to be implemented for the reflection types,
         * so we implement it here.
         * 
         * @param left
         *            One of two types to compare.
         * @param right
         *            One of two types to compare.
         * @return True if the two types are equal.
         */
        private static boolean equals(Type left, Type right) {
            if (left == right) {
                return true;
            }
            if (left instanceof ParameterizedType) {
                if (right instanceof ParameterizedType) {
                    return equals((ParameterizedType) left, (ParameterizedType) right);
                }
            }
            if (left instanceof WildcardType) {
                if (right instanceof WildcardType) {
                    return equals((WildcardType) left, (WildcardType) right);
                }
            }
            return left.equals(right);
        }

        /**
         * Generate a hash code from the given parameterized type. Create a hash
         * code by combining the hash codes of the raw type, the owner type if
         * any, and the actual type parameters.
         * 
         * @param pt
         *            The parameterized type.
         * @return The hash code.
         */
        private static int makeHashCode(ParameterizedType pt) {
            int hashCode = 1999;
            Type[] actual = pt.getActualTypeArguments();
            for (int i = 0, stop = actual.length; i < stop; i++) {
                hashCode = hashCode * 37 + makeHashCode(actual[i]);
            }
            hashCode = hashCode * 37 + makeHashCode(pt.getOwnerType());
            hashCode = hashCode * 37 + makeHashCode(pt.getRawType());
            return hashCode;
        }

        /**
         * Generate a hash code from the given type. The method will recursively
         * generate a hash code that combines the hash codes of the type and all
         * of the type parameters if the given type is a parameterized type.
         * 
         * @param type
         *            The type.
         * @return The hash code.
         */
        private static int makeHashCode(Type type) {
            if (type == null) {
                return 7;
            }
            if (type instanceof ParameterizedType) {
                return makeHashCode((ParameterizedType) type);
            }
            return type.hashCode();
        }

        /**
         * Return a hash code that combines the hash code of the underlying type
         * which includes all of the type parameters if the underlying type is a
         * parameterized type.
         * 
         * @return The hash code.
         */
        @Override
        public int hashCode() {
            return hashCode;
        }

        /**
         * Create a string that looks like the type declaration.
         * 
         * @return A string.
         */
        @Override
        public String toString() {
            if (type instanceof Class<?>) {
                return ((Class<?>) type).getName();
            }
            return type.toString();
        }
    }

    /**
     * A type-safe heterogeneous container for a single generic object that
     * preserves type information and safely casts the generic object back to
     * its generic type.
     * 
     * @author Alan Gutierrez
     */
    public final static class Box implements Serializable {
        /** The serial version id. */
        private static final long serialVersionUID = 1L;

        /** The super type token key. */
        public final Key key;

        /** The object. */
        public final Object object;

        /**
         * Create a box that associates the given key with the given object.
         * 
         * @param key
         *            The key.
         * @param object
         *            The object.
         */
        Box(Key key, Object object) {
            this.key = key;
            this.object = object;
        }

//        /**
//         * Create a box around the given object of a class that has no generic
//         * type parameters.
//         * 
//         * @param object
//         *            The object to box.
//         */
//        public Box(Object object) {
//            this.key = new Key(object.getClass());
//            this.object = object;
//        }

        /**
         * Cast the given object to the given class.
         * 
         * @param <C>
         *            The type to cast to.
         * @param castClass
         *            The class to cast to.
         * @return The contained object cast to the class.
         * @exception ClassCastException
         *                If the object is not of the given type.
         */
        public <C> C cast(Class<C> castClass) {
            return cast(new Ilk<C>(castClass));
        }

        /**
         * Cast the given object to the given class.
         * 
         * @param <C>
         *            The type to cast to.
         * @param ilk
         *            The super type token of the type to cast to.
         * @return The contained object cast to the type.
         * @exception ClassCastException
         *                If the object is not of the given type.
         */
        public <C> C cast(Ilk<C> ilk) {
            if (ilk.key.isAssignableFrom(key)) {
                return UncheckedCast.<C>cast(object);
            }
            throw new ClassCastException();
        }
    }
}
